package {	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.geom.Point;	import fl.controls.RadioButton;	import fl.controls.RadioButtonGroup;	import flash.net.SharedObject;	import flash.utils.*;	import flash.events.TimerEvent;	import flash.utils.Timer;	//import flash.system.System;		public class Main extends Sprite { // this class implements all the main logic		//some color related constants		private var SELECTION_COLOR = 0xff0000;		private var NORMAL_COLOR = 0x000000;		private var FRAME_COLOR = 0x999999;				private var initPos:Point = new Point(); //the intial mouse position is stored here while dragging		private var array:ExtendedArray = new ExtendedArray(); // all the graphical objects are stored here		private var drawingMode:Boolean = true, selectionFrameMode:Boolean = false, firstMove:Boolean = true, firstKeyMove:Boolean = true, notClicked = true, mouseActivated = false; // various modes. used in "if" statements		private var draggable = null; //the pointer to the draggable GeoPoint. defined in onMousedown(). nullified in onMouseup()		private var radioGroup:RadioButtonGroup = new RadioButtonGroup("radioGroup"); // the group of radiobuttons. radiobuttons were created graphically		private var point1:GeoPoint,point2:GeoPoint; // pointers to the end points of a GeoLine instance. used in dragging		private var point1Existed,point2Existed; 		private var selectedObjects:ExtendedArray = new ExtendedArray(); // here the pointers to selected objects (those highlighted red) are stored		private var hisObj:HistoryObject = new HistoryObject();		private var clipboard = null, randomNum = 0; //copy/paste variables. randomNum that is used in copy/paste to ensure that the ids are unique.		private var so:SharedObject; //this is where history data is saved		private var constTg = null; // used while dragging		private var webConnect:WebConnect;//================================================== M a i n ===============================================================================		public function Main() {			so = SharedObject.getLocal('history2'); //takes the history strings from the sandbox on your computer			//so.data.history = null; //used for debugging			if(so.data.history == null) { // if there is no history saved				historyLevel.text = String(hisObj.position);				TextArea(textArea).appendText("History is empty");			}			else {				try { // there is an error when history was not cleaned by "purge" button but was cleaned by selecting and using "delete" button					trace(so.data.history);					hisObj.pushRaw(so.data.history);					TextArea(textArea).text = String(so.data.history);					array = hisObj.getPresentFinal();					trace(array[0].hide);					if(array.length == 0) {						hisObj.position--;						hisObj.data.pop();					}					redrawScreen();				} catch(e:Error) {					trace(e);					so.data.history = null;					historyLevel.text = String(hisObj.position);					TextArea(textArea).appendText("History is empty");				}			}			historyLevel.text = String(hisObj.position); //historyLevel is a textfield on the stage			//radiobutton group initialization			radioGroup.addRadioButton(pointRadio); 			radioGroup.addRadioButton(lineRadio);			radioGroup.addRadioButton(circleRadio);			radioGroup.addRadioButton(selectRadio);						pointRadio.mouseFocusEnabled = false;			lineRadio.mouseFocusEnabled = false;			circleRadio.mouseFocusEnabled = false;			selectRadio.mouseFocusEnabled = false;			this.parent.doubleClickEnabled = true;						//adding mouse and keyboard event listeners 			this.parent.addEventListener(MouseEvent.MOUSE_DOWN, onMousedown);			this.parent.addEventListener(MouseEvent.MOUSE_UP, onMouseup);			this.parent.addEventListener(MouseEvent.DOUBLE_CLICK, onDoubleclick);			this.parent.addEventListener(KeyboardEvent.KEY_DOWN, keyPressed);			this.parent.addEventListener(MouseEvent.MOUSE_MOVE, onMousemove);			this.parent.addEventListener(KeyboardEvent.KEY_UP, onKeyup);			//adding event listeners to buttons on the stage			purgeButton.addEventListener(MouseEvent.CLICK, function(e){so.data.history=null;});			loadButton.addEventListener(MouseEvent.CLICK, onLoadButton);			hideButton.addEventListener(MouseEvent.CLICK, onHide);			showAllButton.addEventListener(MouseEvent.CLICK, onShow);			copyButton.addEventListener(MouseEvent.CLICK, onCopy);			pasteButton.addEventListener(MouseEvent.CLICK, onPaste);			backInHistoryButton.addEventListener(MouseEvent.CLICK, onBack);			forthInHistoryButton.addEventListener(MouseEvent.CLICK, onForth);			deleteButton.addEventListener(MouseEvent.CLICK, onDelete);						//webConnect = new WebConnect();			//webConnect.addEventListener("scriptReceived", onScriptReceived);		}				/*public function onClick(e:MouseEvent) { // custom double click implementation, it is more flexible - you can adjust the time interval between clicks			if(notClicked) {				notClicked = false;				var pane = this.parent;				pane.addEventListener(MouseEvent.MOUSE_DOWN, onComplete);				var timer:Timer = new Timer(35, 1);				timer.addEventListener(TimerEvent.TIMER_COMPLETE, onComplete);				timer.start();				function onComplete(e:Event) {					timer.removeEventListener(TimerEvent.TIMER_COMPLETE, onComplete); 					pane.removeEventListener(MouseEvent.MOUSE_DOWN, onComplete);					notClicked = true;					if(!(e.target is Timer)) onDoubleclick(MouseEvent(e));				}			}		}		*/				private function onScriptReceived(e) {			var script; //= webConnect.currentScript;			trace(script);			hisObj.pushText(script);			so.data.history = hisObj.getRaw(); 			array = hisObj.getPresentFinal();			historyLevel.text = String(hisObj.position);			//textArea.text = 			redrawScreen();		}		//================================================== o n C o p y ========================================================================		private function onCopy(e) { // copies stage graphic objects to clipboard			clipboard = null;			clipboard = hisObj.convertToInnerFormat(selectedObjects, true);			trace("copy");		}//================================================== o n P a s t e ========================================================================		private function onPaste(e) { // paste stage graphic objects. for script pasting use your system paste			var obj, obj2;			randomNum = Math.floor(Math.random()*10000);			for each(obj in clipboard) {				obj.id = Number(obj.id) + randomNum;				if(obj is GeoPoint) {					var a = new ExtendedArray();					for each(obj2 in obj.adjLines) {						a.push(Number(obj2) + randomNum);					}					obj.adjLines = a;					var b = new ExtendedArray();					for each(obj2 in obj.dependantCircles) {						b.push(Number(obj2) + randomNum);					}					obj.dependantCircles = b;				}				else if(obj is GeoLine) {					obj.point1 = Number(obj.point1) + randomNum;					obj.point2 = Number(obj.point2) + randomNum;				}				else if(obj is GeoCircle) {					obj.centerPoint = Number(obj.centerPoint) + randomNum;				}			}			hisObj.data.push(clipboard.getCopy());			hisObj.position++;			var toAdd = hisObj.getPresentFinal();			hisObj.data.pop();			hisObj.position--;			selectedObjects = toAdd;			for each(obj in toAdd) {				array.push(obj);			}			updateHistory();			redrawScreen();			trace("paste");		}		//================================================== o n B a c k ========================================================================		private function onBack(e) { // go back in history			array = hisObj.getPrevious();			so.data.history = hisObj.getRaw();			TextArea(textArea).text = String(so.data.history);			historyLevel.text = String(hisObj.position);			redrawScreen();		}		//================================================== o n F o r t h ========================================================================		private function onForth(e) { // go forward in history			array = hisObj.getNext();			so.data.history = hisObj.getRaw();			TextArea(textArea).text = String(so.data.history);			historyLevel.text = String(hisObj.position);			redrawScreen();		}		//================================================== o n H i d e ==============================================================================		private function onHide(e) { //hides selected objects			for(var i:int=0; i<selectedObjects.length; i++) {				selectedObjects[i].hide = 1; //every object has a hide property which is saved to history			}			if(selectedObjects.length > 0) {				selectedObjects.deleteData();				redrawScreen();				updateHistory();			}		}		//================================================== o n S h o w ============================================================================		private function onShow(e) { //shows all hidden objects			var changes:Boolean = false;			for(var i:int=0; i<array.length; i++) {				if(array[i].hide) {					changes = true;					array[i].hide = 0;				}			}			if(changes) {				redrawScreen();				updateHistory();			}		}		//================================================== o n L o a d B u t t o n ========================================================================		private function onLoadButton(e:MouseEvent) { // code for the button that triggers the loading of the user saved history text			if(textArea.text.match(/ */g).length == 0 && textArea.text.length != 0 && (hisObj.data.length == 0 || hisObj.getRaw().toString() !== textArea.text)) {				hisObj.pushText(textArea.text);				so.data.history = hisObj.getRaw(); 				array = hisObj.getPresentFinal();				historyLevel.text = String(hisObj.position);				redrawScreen();			}		}		//================================================== o n D e l e t e ========================================================================		private function onDelete(e) { // removes selected objects from the stage. doesn't apply to hidden objects because they are not selectable			var obj, line, circle;			for each (obj in selectedObjects) {				if (obj is GeoPoint) {					for each (line in obj.adjLines) {						if (line.point1 != obj) {							line.point1.adjLines.remove(line);						}						else if (line.point2 != obj) {							line.point2.adjLines.remove(line);						}						array.remove(line);					}					for each (circle in obj.dependantCircles) {						array.remove(circle);					}				}				else if (obj is GeoLine) {					var counter:int = 0;					if (obj.point1 != null) {						for each (line in obj.point1.adjLines) {							if (line == obj) {								obj.point1.adjLines.splice(counter, 1);							}							counter++;						}						counter = 0;					}					if (obj.point2 != null) {						for each (line in obj.point2.adjLines) {							if (line == obj) {								obj.point2.adjLines.splice(counter, 1);							}							counter++;						}					}				}				else if (obj is GeoCircle) {					obj.centerPoint.dependantCircles.remove(obj);				}				array.remove(obj);			}			selectedObjects.deleteData();			redrawScreen();			trace("object/objects deleted");			updateHistory();		}		//================================================== o n D o u b l e c l i c k ========================================================================		private function onDoubleclick(e:MouseEvent) { // mouse doubleclick listener method used to select the selectable object and deselect all the others			trace("doubleClick");			if (radioGroup.selection.name == "selectRadio") {				var obj;				function addDoubleClick(obj) {					selectedObjects.deleteData();					selectedObjects.push(obj);					redrawScreen();				}				for each (obj in array) {					if (obj is GeoPoint && checkGeoPoint(obj, e)) {						addDoubleClick(obj);						return;					}				}				for each(obj in array) {					if(obj is GeoLine && checkGeoLine(obj, e) || obj is GeoCircle && checkGeoCircle(obj, e)) {						addDoubleClick(obj);						return;					}				}			}		}		//================================================== o n M o u s e d o w n ========================================================================		private function onMousedown(e:MouseEvent) { // called when user presses the left mouse button			var obj; // is used many many times as a universal pointer to objects in "array" and selectedObjects			if (e.target == this.parent) { // if the user clicks on the stage, not a displayobject like radiobutton				if(radioGroup.selection.name == "pointRadio") {  // if the radiobutton selected at this moment is called "pointRadio" / if the point creating mode is on					selectedObjects.deleteData();					var point:GeoPoint = new GeoPoint();					point.x1 = e.stageX;					point.y1 = e.stageY;					var creationPossible = true;					for each (obj in array) {						//checks if it is possible to create a point by going through the array of objects on the screen and checking if any point is critically close						if (obj is GeoPoint && checkGeoPoint(obj, e)) {							creationPossible = false;							break;						}					}					if(creationPossible) {						//creation of a point						alignPoint(point, e);						array.push(point);						updateHistory();						trace("point put");					}				}				else if (radioGroup.selection.name == "circleRadio") { //if the circle creating mode is on					selectedObjects.deleteData();					point1Existed = false;					for each (obj in array) {						if (obj is GeoPoint && checkGeoPoint(obj, e)) {							initPos.x = obj.x1;							initPos.y = obj.y1;							point1Existed = true;							point1 = obj;							break;						}					}					if(!point1Existed) {						createStartPoint(e);						alignPoint(point1, e);					}					mouseActivated = true;					trace("circle building started");				}				else if (radioGroup.selection.name == "lineRadio") { // if line drawing mode is on					selectedObjects.deleteData();					point1Existed = false;					point2Existed = false;					for each (obj in array) {						/**						* if the distance to any GeoPoint is approximately less than 4 pixels (this logical expression defines a 8x8 square in fact						* and it is more efficient here because the circle expression is not much more precise but requires more calculations)						* then the line drawing will be done beginning with the existing point which happens to be obj.						**/						if (obj is GeoPoint && checkGeoPoint(obj, e)) {							point1 = obj;							initPos.x = obj.x1; // initPos defined is equal to 							initPos.y = obj.y1;							this.graphics.moveTo(obj.x1, obj.y1); // the "pencil pin" is moved to the initPos							point1Existed = true;							break;						}					}					if (!point1Existed) { // if a user clicked somewhere not in vicinity of the existing GeoPoint then the new point is created at this position 						createStartPoint(e); 						alignPoint(point1, e);					}					mouseActivated = true; // onMousemove is from now on being called				}				/**				* if selectionMode is on, either selection (and subsequent removal) or dragging can be done				* these actions mutually interfere in some places of this code, therefore many amendments need to be done				**/				else if (radioGroup.selection.name == "selectRadio") { 					initPos.x = e.stageX; // initPos is always the initial mouse position					initPos.y = e.stageY;					var nothingFound = true; // if there was no GeoPoint found nearby then nothingFound					function addSingleClick(obj) {						draggable = obj;						nothingFound = false;						selectionFrameMode = false;						mouseActivated = true;						if (selectedObjects.indexOf(obj) == -1) {// if an object was not previously selected, it is selected							trace("object selected");							selectedObjects.push(obj);						}						else { // otherwise it is deselected							trace("object deselected");							selectedObjects.remove(obj);						}						redrawScreen();					}					for each (obj in array) {						if (obj is GeoPoint && checkGeoPoint(obj, e)) { // clicked on an object							addSingleClick(obj);							break;						}					}					for each(obj in array) {						if(nothingFound)						if((obj is GeoLine && checkGeoLine(obj, e) || obj is GeoCircle && checkGeoCircle(obj, e))) {							addSingleClick(obj);							break;						}					}					if (nothingFound) { // if nothing was found in immediate vicinity, in other words user pushed mousebutton on free space						selectionFrameMode = true; // so if nothing was found, selectionFrame will appear in onMousemove()						initPos.x = e.stageX;						initPos.y = e.stageY;						selectedObjects.deleteData(); // all objects are deselected						redrawScreen();						mouseActivated = true;					}				}			}		}//================================================== o n M o u s e m o v e ========================================================================		private function onMousemove(e:MouseEvent) {			if(mouseActivated) {			var obj;			this.graphics.clear(); // delete all graphic content from the stage			this.graphics.lineStyle(2);			if (radioGroup.selection.name == "circleRadio") {				var radius = Math.sqrt(Math.pow(e.stageX-initPos.x, 2) + Math.pow(e.stageY-initPos.y, 2));				this.graphics.drawCircle(initPos.x, initPos.y, radius);				if(!point1Existed) {					this.graphics.lineStyle(2, NORMAL_COLOR);					this.graphics.beginFill(NORMAL_COLOR);					this.graphics.drawCircle(initPos.x, initPos.y, 3);					this.graphics.endFill();				}			}			else if (radioGroup.selection.name == "lineRadio") { // if line drawing mode is on				this.graphics.moveTo(initPos.x, initPos.y); // pencil pin is moved to initPos				this.graphics.lineTo(e.stageX, e.stageY); // the line from the initPos to current mouse position is drawn				this.graphics.lineStyle(2, NORMAL_COLOR);				this.graphics.beginFill(NORMAL_COLOR);				this.graphics.drawCircle(e.stageX, e.stageY, 3); // a circle is drawn in the mouse position				this.graphics.drawCircle(initPos.x, initPos.y, 3); // and in the initial position				this.graphics.endFill();			}			else if (radioGroup.selection.name == "selectRadio") { 				if (selectionFrameMode) { 				    //selection frame is drawn					this.graphics.lineStyle(1, FRAME_COLOR);					this.graphics.drawRect(initPos.x, initPos.y, e.stageX-initPos.x, e.stageY-initPos.y);					this.graphics.lineStyle(2);				}				else { // otherwise the draggable object is dragged					if(firstMove) 						if(selectedObjects.indexOf(draggable) == -1) selectedObjects.push(draggable);					firstMove = false;					var dx = e.stageX - initPos.x;					var dy = e.stageY - initPos.y;					function adjustChildPointsOfLines(point, dx, dy) {  // this recursive local function used to adjust points of consequently joined lines						for each (line in point.adjLines) {							var kx=0, ky=0, point1, point2, dif1, dif2;							if(line.point1 == point) {								point1 = line.point2;								point2 = line.point1;							}							else if(line.point2 == point) {								point2 = line.point2;								point1 = line.point1;							}							dif1 = point2.x1 - point1.x1;							dif2 = point2.y1 - point1.y1;							if((dif1 - dx) != 0) kx = dif1/(dif1 - dx);							if((dif2 - dy) != 0) ky = dif2/(dif2 - dy);							for each (var p in line.childPoints) {								if(!p.wasDragged) {									p.wasDragged = true;									var initialX = p.x1;									var initialY = p.y1;									if((dif1 - dx) != 0) p.x1 += (p.x1 - point1.x1)*kx - (p.x1 - point1.x1);									else p.x1 += dx;									if((dif2 - dy) != 0) p.y1 += (p.y1 - point1.y1)*ky - (p.y1 - point1.y1);									else p.y1 += dy;									if((dif1 - dx) != 0 || (dif2 - dy) != 0) p.alignToLine(line);									adjustChildPointsOfLines(p, p.x1 - initialX, p.y1 - initialY);									adjustChildPointsOfCircles(p, p.x1 - initialX, p.y1 - initialY);								}							}						}					}					function adjustChildPointsOfCircles(point, dx, dy) { // this recursive local function used to adjust points of consequently joined circles						for each (var circle in point.dependantCircles) {							for each (var p in circle.childPoints) {								if(!p.wasDragged) {									p.wasDragged = true;									p.x1 += dx;									p.y1 += dy;									adjustChildPointsOfCircles(p, dx, dy);									adjustChildPointsOfLines(p, dx, dy);								}							}						}					}					var initialX, initialY, line;					for each(obj in selectedObjects) {						draggable = obj; //what is being dragged at the moment						if (draggable is GeoPoint && !draggable.wasDragged) {							if(draggable.parentObject is GeoLine) {								initialX = draggable.x1;								initialY = draggable.y1;								draggable.x1 = e.stageX;								draggable.y1 = e.stageY;								var point = draggable.alignToLine(draggable.parentObject);								var p1 = draggable.parentObject.point1;								var p2 = draggable.parentObject.point2;								if((point.x > p1.x1 && point.y > p1.y1 && point.x > p2.x1 && point.y > p2.y1) ||								(point.x > p1.x1 && point.y < p1.y1 && point.x > p2.x1 && point.y < p2.y1) ||							    (point.x < p1.x1 && point.y < p1.y1 && point.x < p2.x1 && point.y < p2.y1) ||								(point.x < p1.x1 && point.y > p1.y1 && point.x < p2.x1 && point.y > p2.y1)) 		{									if(Math.abs(draggable.x1 - p1.x1) + Math.abs(draggable.y1 - p1.y1) < Math.abs(draggable.x1 - p2.x1) + Math.abs(draggable.y1 - p2.y1)) {										draggable.x1 = p1.x1										draggable.y1 = p1.y1;									} else {										draggable.x1 = p2.x1										draggable.y1 = p2.y1;									}								} else {									draggable.x1 = point.x;									draggable.y1 = point.y;								}								adjustChildPointsOfLines(draggable, draggable.x1 - initialX, draggable.y1 - initialY);								adjustChildPointsOfCircles(draggable, draggable.x1 - initialX, draggable.y1 - initialY);							}							else if(draggable.parentObject is GeoCircle) {								initialX = draggable.x1;								initialY = draggable.y1;								draggable.x1 = e.stageX;								draggable.y1 = e.stageY;								draggable.alignToCircle(draggable.parentObject);								adjustChildPointsOfLines(draggable, draggable.x1 - initialX, draggable.y1 - initialY);								adjustChildPointsOfCircles(draggable, draggable.x1 - initialX, draggable.y1 - initialY);							}							else {								trace("dragging");								draggable.wasDragged = true;								draggable.x1 += dx;								draggable.y1 += dy;								adjustChildPointsOfLines(draggable, dx, dy);								adjustChildPointsOfCircles(draggable, dx, dy);							}						}						else if (draggable is GeoCircle) {							if(selectedObjects.length>1) {								if(!draggable.centerPoint.wasDragged) {									draggable.centerPoint.x1 += dx;									draggable.centerPoint.y1 += dy;									draggable.centerPoint.wasDragged = true;									adjustChildPointsOfCircles(draggable.centerPoint, dx, dy);									adjustChildPointsOfLines(draggable.centerPoint, dx, dy);								}							}							else {								trace("radius change");								draggable.radius = Math.sqrt(Math.pow(draggable.centerPoint.x1-e.stageX, 2) + Math.pow(draggable.centerPoint.y1-e.stageY, 2));								for each(point in draggable.childPoints) {									initialX = point.x1;									initialY = point.y1;									point.alignToCircle(draggable);									adjustChildPointsOfLines(point, point.x1-initialX, point.y1-initialY);									adjustChildPointsOfCircles(point, point.x1-initialX, point.y1-initialY);								}							}						}						else if (draggable is GeoLine) {							/*for each(point in draggable.childPoints) {								point.x1 += dx;								point.y1 += dy;								point.wasDragged = true;								adjustChildPointsOfLines(point, dx, dy);								adjustChildPointsOfCircles(point, dx, dy);							}*/							var pointA, pointB, initialPosA:Point = new Point(), initialPosB:Point = new Point(), bothAreBinded:Boolean = false, pointStopped = false;							if(draggable.point1.parentObject != null && draggable.point2.parentObject != null) bothAreBinded = true;						    if(draggable.point1.parentObject != null) {								pointA = draggable.point1;								pointB = draggable.point2;							} else if(draggable.point2.parentObject != null) {								pointA = draggable.point2;								pointB = draggable.point1;							}							if(pointA != null && pointB != null) {								trace("ololo");								initialPosA.x = pointA.x1;								initialPosA.y = pointA.y1;								initialPosB.x = pointB.x1;								initialPosB.y = pointB.y1;								if(constTg == null) constTg =  (draggable.point1.y1-draggable.point2.y1)/(draggable.point1.x1-draggable.point2.x1);								trace(constTg);								var b = e.stageY - constTg*e.stageX;								var tg2 = (pointA.parentObject.point1.y1-pointA.parentObject.point2.y1)/(pointA.parentObject.point1.x1-pointA.parentObject.point2.x1);								var b2 = pointA.parentObject.point1.y1 - tg2*pointA.parentObject.point1.x1;								var x2 = (constTg*pointA.x1 + b - b2)/tg2;								var y2 = tg2*x2 + b2;								pointA.x1 = x2;								pointA.y1 = y2;								pointA.wasDragged = true;								pointStopped = pointA.tryBlocking();								trace(pointStopped, pointA.parentObject, pointB.parentObject);								if(bothAreBinded && !pointStopped) {									var tg3 = (pointB.parentObject.point1.y1-pointB.parentObject.point2.y1)/(pointB.parentObject.point1.x1-pointB.parentObject.point2.x1);									var b3 = pointB.parentObject.point1.y1 - tg3*pointB.parentObject.point1.x1;									var x3 = (constTg*pointB.x1 + b - b3)/tg3;									var y3 = tg3*x3 + b3;									pointB.x1 = x3;									pointB.y1 = y3;									if(pointB.tryBlocking()) {										pointA.x1 = initialPosA.x;										pointA.y1 = initialPosA.y;									}																		}								else if(!pointStopped) { 									pointB.x1 += dx;									pointB.y1 += dy;								}								pointB.wasDragged = true;								for each(point in draggable.childPoints) {									if(!point.wasDragged) {										point.wasDragged = true;										var initPosX =  point.x1; 										var initPosY =  point.y1; 										var difOldX = initialPosB.x - initialPosA.x;										var difOldY = initialPosB.y - initialPosA.y;										var difNewX = pointB.x1 - pointA.x1;										var difNewY = pointB.y1 - pointA.y1;										var pointDifOldX = point.x1 - initialPosA.x;										var pointDifOldY = point.y1 - initialPosA.y;										var ratioX = pointDifOldX/difOldX;										var ratioY = pointDifOldY/difOldY;										var pointDifNewX = ratioX*difNewX;										var pointDifNewY = ratioY*difNewY;										point.x1 = pointA.x1 + pointDifNewX;										point.y1 = pointA.y1 + pointDifNewY;										adjustChildPointsOfLines(point, point.x1 - initPosX, point.y1 - initPosY);										adjustChildPointsOfCircles(point, point.x1 - initPosX, point.y1 - initPosY);									}								}							}							else {								for each(point in draggable.childPoints) {									point.x1 += dx;									point.y1 += dy;									point.wasDragged = true;									adjustChildPointsOfLines(point, dx, dy);									adjustChildPointsOfCircles(point, dx, dy);								}								if(!draggable.point1.wasDragged) {									draggable.point1.x1 += dx;									draggable.point1.y1 += dy;									draggable.point1.wasDragged = true;									adjustChildPointsOfLines(draggable.point1, dx, dy);									adjustChildPointsOfCircles(draggable.point1, dx, dy);								}								if(!draggable.point2.wasDragged) {									draggable.point2.x1 += dx;									draggable.point2.y1 += dy;									draggable.point2.wasDragged = true;									adjustChildPointsOfLines(draggable.point2, dx, dy);									adjustChildPointsOfCircles(draggable.point2, dx, dy);								}							}						}					}					for each(obj in array) {						if(obj is GeoPoint) obj.wasDragged = false;					}					initPos.x = e.stageX;					initPos.y = e.stageY;				}			}			drawScreen();			}			mousePos.text = "x= " + e.stageX + " y= " + e.stageY;		}//================================================== o n M o u s e u p ========================================================================		private function onMouseup(e:MouseEvent) { //mouse button is released			constTg = null;			if (e.target == this.parent) { 				var obj;				if (radioGroup.selection.name == "circleRadio") { //if circle mode is on					var gc:GeoCircle = new GeoCircle();					gc.radius = Math.sqrt(Math.pow(e.stageX-initPos.x, 2) + Math.pow(e.stageY-initPos.y, 2));					if(gc.radius > 6) {						point1.dependantCircles.push(gc);						gc.centerPoint = point1;						array.push(gc);						if(!point1Existed) array.push(point1);						updateHistory();					}				}				else if (radioGroup.selection.name == "lineRadio") {					var gs:GeoLine = new GeoLine();					for each (obj in array) {						if (obj is GeoPoint && checkGeoPoint(obj, e)) {							point2 = obj;							point2Existed = true;							break;						}					}					if (!point2Existed) {						point2 = new GeoPoint();						point2.x1 = e.stageX;						point2.y1 = e.stageY;						this.graphics.drawCircle(point2.x1, point2.y1, 3);						alignPoint(point2, e);					}					gs.point1 = point1;					gs.point2 = point2;					if (Math.sqrt(Math.pow(point1.x1 - point2.x1,2) + Math.pow(point1.y1 - point2.y1,2)) > 6) {						array.push(GeoLine(gs));						point1.adjLines.push(gs);						point2.adjLines.push(gs);						if (!point1Existed) {							array.push(GeoPoint(point1));						}						if (!point2Existed) {							array.push(GeoPoint(point2));						}						trace("new line created");						updateHistory();					}				}				if (radioGroup.selection.name == "selectRadio") {					if(selectionFrameMode && Math.abs(initPos.x-e.stageX)>4 && Math.abs(initPos.y-e.stageY)>4) {						//these statements find the boundaries of the selection frame						var leftX = initPos.x<e.stageX ? initPos.x : e.stageX;						var rightX = initPos.x>e.stageX ? initPos.x : e.stageX;						var topY = initPos.y<e.stageY ? initPos.y : e.stageY;						var bottomY = initPos.y>e.stageY ? initPos.y : e.stageY;						var somethingSelected:Boolean = false						for each(obj in array) {							if(!obj.hide) {								//boolean statement to check what selection frame is selecting a paint								if(obj is GeoPoint && obj.x1>=leftX && obj.x1<=rightX && obj.y1>=topY && obj.y1<=bottomY) {									selectedObjects.push(obj);									somethingSelected = true;								}								else if(obj is GeoCircle) {									var center = obj.centerPoint;									var distSq1 = (Math.pow(center.x1-leftX, 2) + Math.pow(center.y1-topY, 2));									var distSq2 = (Math.pow(center.x1-leftX, 2) + Math.pow(center.y1-bottomY, 2));									var distSq3 = (Math.pow(center.x1-rightX, 2) + Math.pow(center.y1-topY, 2));									var distSq4 = (Math.pow(center.x1-rightX, 2) + Math.pow(center.y1-bottomY, 2));									var radiusSq = obj.radius*obj.radius;																		var distLeft = Math.abs(center.x1 - leftX);									var distRight = Math.abs(center.x1 - rightX);									var distTop = Math.abs(center.y1 - topY);									var distBottom = Math.abs(center.y1 - bottomY);									//boolean statement to check when selection frame is selecting a circle									if(!((distSq1<radiusSq && distSq2<radiusSq && distSq3<radiusSq && distSq4<radiusSq) || (distSq1>radiusSq && distSq2>radiusSq && distSq3>radiusSq && distSq4>radiusSq))								  	|| (center.x1<rightX && center.x1>leftX && center.y1<bottomY && center.y1>topY) && !(distSq1<radiusSq && distSq2<radiusSq && distSq3<radiusSq && distSq4<radiusSq)								  	|| ((center.y1<bottomY && center.y1>topY && (distLeft<obj.radius || distRight<obj.radius)) || (center.x1<rightX && center.x1>leftX && (distTop<obj.radius || distBottom<obj.radius))) && !(distSq1<radiusSq && distSq2<radiusSq && distSq3<radiusSq && distSq4<radiusSq)) {											selectedObjects.push(obj);											somethingSelected = true;											trace("circle selected");									}								}							}						}						for each(obj in array) { // the second array enumeration is done on purpose! don't change anything here							if(!obj.hide) {								if(obj is GeoLine) {									if((selectedObjects.indexOf(obj.point1) != -1 && selectedObjects.indexOf(obj.point2) != -1) || 									   (obj.point1.x1 >= leftX && obj.point1.x1 <= rightX && obj.point1.y1 >= topY && obj.point1.y1 <= bottomY)									   && (obj.point2.x1 >= leftX && obj.point2.x1 <= rightX && obj.point2.y1 >= topY && obj.point2.y1 <= bottomY)) {											selectedObjects.push(obj);											somethingSelected = true;											continue;									} 									var vertical = false;									var tg:Number = (obj.point1.y1-obj.point2.y1)/(obj.point1.x1-obj.point2.x1);									if(obj.point1.x1-obj.point2.x1 == 0) 										tg = -9999999;									var b:Number = obj.point1.y1 - tg*obj.point1.x1;									var intersections:Array = new Array();									intersections.push(new Point((topY-b)/tg, topY));									intersections.push(new Point((bottomY-b)/tg, bottomY));									intersections.push(new Point(leftX, tg*leftX+b))									intersections.push(new Point(rightX, tg*rightX+b));									for each(var point in intersections) {										this.graphics.beginFill(0x000bf0);										this.graphics.drawCircle(point.x, point.y, 2);										var distance1 = Math.sqrt(Math.pow(point.x - obj.point1.x1,2) + Math.pow(point.y - obj.point1.y1,2));										var distance2 = Math.sqrt(Math.pow(point.x - obj.point2.x1,2) + Math.pow(point.y - obj.point2.y1,2));										if (((distance1 + distance2)-Math.sqrt(Math.pow(obj.point2.x1-obj.point1.x1, 2) + Math.pow(obj.point2.y1-obj.point1.y1, 2)))<0.01) {											if((point.x>leftX && point.x<rightX) || (point.y>topY && point.y<bottomY)) {												if(selectedObjects.indexOf(obj) == -1) {													selectedObjects.push(obj);													trace("line selected");													somethingSelected = true;												}											}										}									}								}							}						}						selectionFrameMode = false;					}					if(draggable != null && !(draggable is GeoPoint)){						if(!firstMove) updateHistory();					}					else if (draggable != null && draggable is GeoPoint) {						for each (obj in array) {							if (obj is GeoPoint && obj != draggable && checkGeoPoint(obj, e)) {								for each (var line in draggable.adjLines) {									if ((line.point1 == draggable && line.point2 == obj) || (line.point1 == obj && line.point2 == draggable)) {											array.remove(line);											draggable.adjLines.remove(line);											obj.adjLines.remove(line);											//trace("line removed 2");									}								}																for each(line in draggable.adjLines) {									var p:GeoPoint;									if(line.point1 != draggable) p = line.point1;									else if(line.point2 != draggable) p = line.point2;									for each(var l in p.adjLines) {										if(l.point1 == obj || l.point2 == obj) {											l.point1.adjLines.remove(l);											l.point2.adjLines.remove(l);											array.remove(l);											//trace("line removed");										}									}								}								for each(var circle in draggable.dependantCircles) {									obj.dependantCircles.push(circle);									circle.centerPoint = obj;								}								for each(line in draggable.adjLines) {									if (line.point1 == draggable) {										line.point1 = obj;										obj.adjLines.push(line);									}									else if (line.point2 == draggable) {										line.point2 = obj;										obj.adjLines.push(line);									}								}								array.remove(draggable);							}						}						if(!firstMove) updateHistory();					}					draggable = null;				}				mouseActivated = false;				firstMove = true;			}			redrawScreen();		}//================================================== keyPressed ========================================================================		private function keyPressed(e:KeyboardEvent) { //keyboard key was pressed			var obj;			if (e.keyCode == 8 && selectedObjects.length > 0) onDelete(e); //deleting objects			else if((e.keyCode == 90 && e.shiftKey) || (e.keyCode == 1103 && e.shiftKey)) onBack(e); // going back in history			else if(((e.keyCode == 88 && e.shiftKey) || (e.keyCode == 1095 && e.shiftKey)) && hisObj.data.length > 0) onForth(e); //going forth in history			else if(((e.keyCode == 86 && e.shiftKey) || (e.keyCode == 1052 && e.shiftKey)) && clipboard != null) onPaste(e); //pasting			else if(selectedObjects.length>0) {				if((e.keyCode == 67 && e.shiftKey) || (e.keyCode == 1057 && e.shiftKey)) onCopy(e); //copying				else if(e.keyCode == 37 || e.keyCode == 39 || e.keyCode == 38 || e.keyCode == 40) { //moving objects					if(firstKeyMove) {						for each(obj in selectedObjects) {							if(obj is GeoLine) {								if(selectedObjects.indexOf(obj.point1) == -1)									selectedObjects.push(obj.point1);								if(selectedObjects.indexOf(obj.point2) == -1)									selectedObjects.push(obj.point2);							}							else if(obj is GeoCircle) {								if(selectedObjects.indexOf(obj.centerPoint) == -1)									selectedObjects.push(obj.centerPoint);							}						}					}					firstKeyMove = false;					var timer = new Timer(10, 4);					timer.addEventListener(TimerEvent.TIMER, function(k){switchStuff();});					timer.start();					switchStuff();					function switchStuff(){						switch(e.keyCode) {							case 37: for each(obj in selectedObjects) if(obj is GeoPoint) obj.x1-=1; break; 							case 39: for each(obj in selectedObjects) if(obj is GeoPoint) obj.x1+=1; break;							case 38: for each(obj in selectedObjects) if(obj is GeoPoint) obj.y1-=1; break;							case 40: for each(obj in selectedObjects) if(obj is GeoPoint) obj.y1+=1; break;						}						redrawScreen();					}				}			}			redrawScreen();		}		//================================================== o n K e y u p ========================================================================		private function onKeyup(e) { // keyboard key was released			if((e.keyCode == 37 || e.keyCode == 39 || e.keyCode == 38 || e.keyCode == 40) && !firstKeyMove && selectedObjects.length>0) {				firstKeyMove = true;				updateHistory();			}		}//================================================== d r a w S c r e e n ========================================================================		private function drawScreen() { // this method draws the screen			//it goes through all the objects in array in draws the shapes accordingly			var obj;			for each (obj in array) {				if(!obj.hide) {					if (obj is GeoLine) {						if (selectedObjects.indexOf(obj) != -1 || (obj == draggable && draggable is GeoLine)) {							this.graphics.moveTo(obj.point1.x1, obj.point1.y1);							this.graphics.lineStyle(2, SELECTION_COLOR);							this.graphics.lineTo(obj.point2.x1, obj.point2.y1);							this.graphics.lineStyle(2);						}						else {							//this.graphics.lineStyle(1);							this.graphics.moveTo(obj.point1.x1, obj.point1.y1);							this.graphics.lineTo(obj.point2.x1, obj.point2.y1);							//this.graphics.lineStyle(1);						}					}					if(obj is GeoCircle) {						if (selectedObjects.indexOf(obj) != -1 || (obj == draggable && draggable is GeoCircle)) {							this.graphics.lineStyle(2, SELECTION_COLOR);							this.graphics.drawCircle(obj.centerPoint.x1, obj.centerPoint.y1, obj.radius);							this.graphics.lineStyle(2);						}						else {							this.graphics.drawCircle(obj.centerPoint.x1, obj.centerPoint.y1, obj.radius);						}					}				}			}			for each (obj in array) {				if (obj is GeoPoint && !obj.hide) {					if (selectedObjects.indexOf(obj) != -1 || (obj == draggable && draggable is GeoPoint)) {						this.graphics.lineStyle(2, SELECTION_COLOR);						this.graphics.beginFill(SELECTION_COLOR);						this.graphics.drawCircle(obj.x1, obj.y1, 3);						this.graphics.endFill();						this.graphics.lineStyle(2);					}					else {						this.graphics.beginFill(NORMAL_COLOR);						this.graphics.drawCircle(obj.x1, obj.y1, 3);					}				}			}		}//================================================== c r e a t e S t a r t P o i n t ========================================================================		private function createStartPoint(e:MouseEvent) { // creates the first point of a new line			initPos.x = e.stageX;			initPos.y = e.stageY;			point1 = new GeoPoint();			point1.x1 = e.stageX;			point1.y1 = e.stageY;			this.graphics.lineStyle(2, NORMAL_COLOR);			this.graphics.beginFill(NORMAL_COLOR);			this.graphics.drawCircle(e.stageX, e.stageY, 3);			this.graphics.endFill();		}		//================================================== a l i g n P o i n t ========================================================================		private function alignPoint(point, e) { //when point is created or moved this method aligns it to an existing circle or a line if one is nearby			for each (var obj in array) {				if(obj is GeoLine && checkGeoLine(obj, e)) {					obj.childPoints.push(point);					point.parentObject = obj;					point.alignToLine(obj);					break;				}				else if(obj is GeoCircle && checkGeoCircle(obj, e)) {					obj.childPoints.push(point);					point.parentObject = obj;					point.alignToCircle(obj);					break;				}			}		}//================================================== c h e c k G e o P o i n t ========================================================================		private function checkGeoPoint(obj:GeoPoint, e:MouseEvent):Boolean { //check if a point is nearby			if(obj.hide) return false;			if(Math.abs(obj.x1 - e.stageX) < 5 && Math.abs(obj.y1 - e.stageY) < 5) return true;			return false;		}		//================================================== c h e c k G e o L i n e ========================================================================		private function checkGeoLine(obj:GeoLine, e:MouseEvent):Boolean { //check if a line is nearby			if(obj.hide) return false;			var distance1 = Math.sqrt(Math.pow(e.stageX - obj.point1.x1,2) + Math.pow(e.stageY - obj.point1.y1,2)); // distance from the mouse position to one end point			var distance2 = Math.sqrt(Math.pow(e.stageX - obj.point2.x1,2) + Math.pow(e.stageY - obj.point2.y1,2)); // and to another end point			if (((distance1 + distance2)-Math.sqrt(Math.pow(obj.point2.x1-obj.point1.x1, 2) + Math.pow(obj.point2.y1-obj.point1.y1, 2)))<0.1 && distance1>4 && distance2>4) return true; // one side of a triangle is never bigger than the sum of two other sides			return false;		}		//================================================== c h e c k G e o C i r c l e ========================================================================		private function checkGeoCircle(obj:GeoCircle, e:MouseEvent):Boolean { //check if a circle is nearby			if(obj.hide) return false;			var dist = Math.sqrt(Math.pow(e.stageX-obj.centerPoint.x1, 2) + Math.pow(e.stageY-obj.centerPoint.y1, 2));			if(Math.abs(obj.radius-dist)<3.5) return true;			return false;		}		//================================================== r e d r a w S c r e e n ========================================================================		private function redrawScreen() { //clears the screen first and then calls the dramScreen() method			this.graphics.clear();			this.graphics.lineStyle(2);			drawScreen();		}//================================================== u p d a t e H i s t o r y ========================================================================		private function updateHistory() { // saves all the changes to the history object (hisObj) and the shared object (so)			hisObj.write(array); 			historyLevel.text = String(hisObj.position);			var h = hisObj.getRaw();			so.data.history = h;			TextArea(textArea).text = String(h);			//webConnect.sendScript(String(h));			so.flush();		}	}}