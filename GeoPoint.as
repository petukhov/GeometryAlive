package  {	import flash.geom.Point;		public class GeoPoint extends ExtendedObject{		var x1:Number, y1:Number;		var adjLines:ExtendedArray = new ExtendedArray();		var dependantCircles:ExtendedArray = new ExtendedArray();		var parentObject;		var wasDragged:Boolean = false;		public function GeoPoint() {			super();		}				public function getCopy():GeoPoint {			var newPoint:GeoPoint = new GeoPoint();			newPoint.id = id;			newPoint.x1 = x1;			newPoint.y1 = y1;			var a = new ExtendedArray();			for(var i:int=0; i<adjLines.length; i++) {				a.push(adjLines[i]);			}			newPoint.adjLines = a;			var b = new ExtendedArray();			for(i=0; i<dependantCircles.length; i++) {				b.push(dependantCircles[i]);			}			newPoint.dependantCircles = b;			//if(newPoint.parentLine != null) newPoint.parentLine = parentLine.getCopy();			newPoint.wasDragged = wasDragged;			newPoint.hide = hide;			return newPoint;		}				public function alignToLine(line:GeoLine):Point { // the name of this method is self explanatory			var tg1:Number, tg2:Number;			if(line.point1.x1-line.point2.x1 == 0) 				tg1 = 9999999999;			else 				tg1 = (line.point1.y1-line.point2.y1)/(line.point1.x1-line.point2.x1);			var b1:Number = line.point1.y1 - tg1*line.point1.x1; 			if(tg1 == 0)  				tg2 = 9999999999;			else 				tg2 = -1/tg1;			var b2:Number = this.y1 - tg2*this.x1;			var xPos = (b2-b1)/(tg1-tg2);			var yPos = tg2*xPos + b2;			this.x1 = xPos;			this.y1 = yPos;										//trace("point aligned to a line");			return(new Point(xPos, yPos));		}				public function alignToCircle(circle:GeoCircle):Point {			var hypothenuse = Math.sqrt(Math.pow(this.y1 - circle.centerPoint.y1, 2) + Math.pow(this.x1 - circle.centerPoint.x1, 2));			var sin = (this.y1 - circle.centerPoint.y1)/hypothenuse;			var cos = (this.x1 - circle.centerPoint.x1)/hypothenuse;			var xPos = cos*circle.radius + circle.centerPoint.x1;			var yPos = sin*circle.radius + circle.centerPoint.y1;			this.x1 = xPos;			this.y1 = yPos;										//trace("point aligned to a circle");			return(new Point(xPos, yPos));		}				public function tryBlocking():Boolean { // used when adjusting the points while dragging			var isPointBlocked = false;			var p1 = this.parentObject.point1;			var p2 = this.parentObject.point2;			if((this.x1 > p1.x1 && this.y1 > p1.y1 && this.x1 > p2.x1 && this.y1 > p2.y1) ||			(this.x1 > p1.x1 && this.y1 < p1.y1 && this.x1 > p2.x1 && this.y1 < p2.y1) ||			(this.x1 < p1.x1 && this.y1 < p1.y1 && this.x1 < p2.x1 && this.y1 < p2.y1) ||			(this.x1 < p1.x1 && this.y1 > p1.y1 && this.x1 < p2.x1 && this.y1 > p2.y1)) 		{				isPointBlocked = true;				if(Math.abs(this.x1 - p1.x1) + Math.abs(this.y1 - p1.y1) < Math.abs(this.x1 - p2.x1) + Math.abs(this.y1 - p2.y1)) {					this.x1 = p1.x1					this.y1 = p1.y1;				} else {					this.x1 = p2.x1					this.y1 = p2.y1;				}			}			return isPointBlocked;		}	}}